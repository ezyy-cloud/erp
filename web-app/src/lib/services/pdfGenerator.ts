/**
 * Enhanced Client-side PDF Generator
 * Generates professional PDF reports with validation, charts, and visual enhancements
 */

import { PDFDocument, StandardFonts, rgb } from 'pdf-lib';
import { validateReportData, calculateSummaryMetrics, type ValidatedReportData } from './reportSchemas';

// Color system (black and white theme)
const COLORS = {
  primary: rgb(0.1, 0.1, 0.1),
  text: rgb(0, 0, 0),
  textSecondary: rgb(0.3, 0.3, 0.3),
  textMuted: rgb(0.5, 0.5, 0.5),
  success: rgb(0.3, 0.3, 0.3),
  warning: rgb(0.4, 0.4, 0.4),
  danger: rgb(0.25, 0.25, 0.25),
  border: rgb(0.8, 0.8, 0.8),
  background: rgb(0.95, 0.95, 0.95),
};

// Page constants
const PAGE_WIDTH = 612; // US Letter width
const PAGE_HEIGHT = 792; // US Letter height
const MARGIN = 60; // Increased from 50 for better spacing
const LINE_HEIGHT = 18;
const SECTION_SPACING = 25;

interface PageContext {
  page: any;
  yPosition: number;
  width: number;
  height: number;
  font: any;
  fontBold: any;
}

/**
 * Generate a PDF from validated report data
 */
export async function generatePDFFromData(reportData: any): Promise<Uint8Array> {
  // Validate data first
  const validation = validateReportData(reportData);
  if (!validation.valid || !validation.validatedData) {
    throw new Error(`Invalid report data: ${validation.error}`);
  }

  const data = validation.validatedData;
  const pdfDoc = await PDFDocument.create();
  const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const helveticaBoldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  // Create first page
  let page = pdfDoc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
  let ctx: PageContext = {
    page,
    yPosition: PAGE_HEIGHT - MARGIN,
    width: PAGE_WIDTH,
    height: PAGE_HEIGHT,
    font: helveticaFont,
    fontBold: helveticaBoldFont,
  };

  // Render header
  ctx = renderHeader(ctx, data);

  // Render executive summary
  const summary = calculateSummaryMetrics(data);
  ctx = renderExecutiveSummary(ctx, summary);

  // Render report-specific content
  if (data.title.toLowerCase().includes('user performance')) {
    ctx = renderUserPerformanceReport(ctx, data as any, pdfDoc);
  } else if (data.title.toLowerCase().includes('task lifecycle')) {
    ctx = renderTaskLifecycleReport(ctx, data as any, pdfDoc);
  } else if (data.title.toLowerCase().includes('project report')) {
    ctx = renderProjectReport(ctx, data as any, pdfDoc);
  } else if (data.title.toLowerCase().includes('company-wide') || data.title.toLowerCase().includes('executive')) {
    ctx = renderCompanyWideReport(ctx, data as any, pdfDoc);
  }

  const pdfBytes = await pdfDoc.save();
  return pdfBytes;
}

/**
 * Render report header
 */
function renderHeader(ctx: PageContext, data: ValidatedReportData): PageContext {
  let y = ctx.yPosition;

  // Company name
  ctx.page.drawText('Ezyy ERP', {
    x: MARGIN,
    y,
    size: 24,
    font: ctx.fontBold,
    color: COLORS.primary,
  });
  y -= 35;

  // Report title
  ctx.page.drawText(data.title, {
    x: MARGIN,
    y,
    size: 18,
    font: ctx.fontBold,
    color: COLORS.text,
  });
  y -= SECTION_SPACING;

  // Metadata
  ctx.page.drawText(`Generated by: ${data.generatedBy}`, {
    x: MARGIN,
    y,
    size: 10,
    font: ctx.font,
    color: COLORS.textMuted,
  });
  y -= LINE_HEIGHT;

  ctx.page.drawText(`Generated at: ${data.generatedAt}`, {
    x: MARGIN,
    y,
    size: 10,
    font: ctx.font,
    color: COLORS.textMuted,
  });
  y -= SECTION_SPACING * 1.5;

  // Divider line
  ctx.page.drawLine({
    start: { x: MARGIN, y: y + 5 },
    end: { x: ctx.width - MARGIN, y: y + 5 },
    thickness: 1,
    color: COLORS.border,
  });
  y -= SECTION_SPACING;

  return { ...ctx, yPosition: y };
}

/**
 * Render executive summary section
 */
function renderExecutiveSummary(ctx: PageContext, summary: ReturnType<typeof calculateSummaryMetrics>): PageContext {
  let y = ctx.yPosition;

  // Section title
  ctx.page.drawText('Executive Summary', {
    x: MARGIN,
    y,
    size: 16,
    font: ctx.fontBold,
    color: COLORS.text,
  });
  y -= LINE_HEIGHT * 1.5;

  // Status indicator
  const statusColor = summary.status === 'healthy' ? COLORS.success : summary.status === 'warning' ? COLORS.warning : COLORS.danger;
  const statusText = summary.status === 'healthy' ? '[HEALTHY]' : summary.status === 'warning' ? '[WARNING]' : '[CRITICAL]';
  
  ctx.page.drawText(statusText, {
    x: MARGIN,
    y,
    size: 12,
    font: ctx.fontBold,
    color: statusColor,
  });
  y -= LINE_HEIGHT * 1.5;

  // Key metrics in two columns
  const leftCol = MARGIN;
  const rightCol = ctx.width / 2 + 20;
  let leftY = y;
  let rightY = y;

  summary.keyMetrics.forEach((metric, index) => {
    const isLeft = index % 2 === 0;
    const x = isLeft ? leftCol : rightCol;
    let currentY = isLeft ? leftY : rightY;

    ctx.page.drawText(`${metric.label}:`, {
      x,
      y: currentY,
      size: 10,
      font: ctx.font,
      color: COLORS.textSecondary,
    });
    currentY -= LINE_HEIGHT;

    ctx.page.drawText(String(metric.value), {
      x: x + 10,
      y: currentY,
      size: 12,
      font: ctx.fontBold,
      color: COLORS.text,
    });
    currentY -= LINE_HEIGHT * 0.5;

    if (isLeft) leftY = currentY;
    else rightY = currentY;
  });

  y = Math.min(leftY, rightY) - SECTION_SPACING;

  // Risk indicators
  if (summary.riskIndicators.length > 0) {
    ctx.page.drawText('Risk Indicators:', {
      x: MARGIN,
      y,
      size: 12,
      font: ctx.fontBold,
      color: COLORS.text,
    });
    y -= LINE_HEIGHT;

    summary.riskIndicators.forEach((indicator) => {
      const severityColor = indicator.severity === 'high' ? COLORS.danger : indicator.severity === 'medium' ? COLORS.warning : COLORS.textSecondary;
      ctx.page.drawText(`  - ${indicator.label}`, {
        x: MARGIN + 10,
        y,
        size: 10,
        font: ctx.font,
        color: severityColor,
      });
      y -= LINE_HEIGHT;
    });
  }

  y -= SECTION_SPACING;

  // Divider
  ctx.page.drawLine({
    start: { x: MARGIN, y: y + 5 },
    end: { x: ctx.width - MARGIN, y: y + 5 },
    thickness: 1,
    color: COLORS.border,
  });
  y -= SECTION_SPACING;

  return { ...ctx, yPosition: y };
}

/**
 * Render user performance report
 */
function renderUserPerformanceReport(ctx: PageContext, data: any, pdfDoc: PDFDocument): PageContext {
  let y = ctx.yPosition;
  const content = data.content;

  // User profile section
  ctx.page.drawText('User Profile', {
    x: MARGIN,
    y,
    size: 14,
    font: ctx.fontBold,
    color: COLORS.text,
  });
  y -= LINE_HEIGHT * 1.5;

  ctx.page.drawText(`Name: ${content.user.full_name || content.user.email}`, {
    x: MARGIN + 10,
    y,
    size: 11,
    font: ctx.font,
    color: COLORS.text,
  });
  y -= LINE_HEIGHT;

  ctx.page.drawText(`Email: ${content.user.email}`, {
    x: MARGIN + 10,
    y,
    size: 11,
    font: ctx.font,
    color: COLORS.text,
  });
  y -= SECTION_SPACING;

  // Task statistics
  const pageCheck1 = checkNewPage(y, ctx, pdfDoc);
  y = pageCheck1.y;
  ctx = pageCheck1.ctx;
  ctx.page.drawText('Task Statistics', {
    x: MARGIN,
    y,
    size: 14,
    font: ctx.fontBold,
    color: COLORS.text,
  });
  y -= LINE_HEIGHT * 1.5;

  const stats = [
    { label: 'Total Tasks Assigned', value: content.taskCounts.total_assigned ?? 0 },
    { label: 'Tasks Completed', value: content.taskCounts.total_completed ?? 0, color: COLORS.success },
    { label: 'Tasks In Progress', value: content.taskCounts.total_in_progress ?? 0 },
    { label: 'Tasks Pending Review', value: content.taskCounts.total_pending_review ?? 0, color: COLORS.warning },
    { label: 'Overdue Tasks', value: content.overdueTasks, color: content.overdueTasks > 0 ? COLORS.danger : COLORS.text },
    { label: 'Completion Rate', value: `${content.completionRate}%` },
  ];

  stats.forEach((stat) => {
    const pageCheck = checkNewPage(y, ctx, pdfDoc);
    y = pageCheck.y;
    ctx = pageCheck.ctx;
    ctx.page.drawText(`${stat.label}:`, {
      x: MARGIN + 20,
      y,
      size: 10,
      font: ctx.font,
      color: COLORS.textSecondary,
    });
    ctx.page.drawText(String(stat.value), {
      x: ctx.width - MARGIN - 100,
      y,
      size: 11,
      font: ctx.fontBold,
      color: stat.color || COLORS.text,
    });
    y -= LINE_HEIGHT;
  });

  // Task lifecycle distribution chart
  y -= SECTION_SPACING;
  const chartResult = renderBarChart(ctx, {
    title: 'Task Distribution by Status',
    data: {
      'Completed': content.taskCounts.total_completed ?? 0,
      'In Progress': content.taskCounts.total_in_progress ?? 0,
      'Pending Review': content.taskCounts.total_pending_review ?? 0,
      'Overdue': content.overdueTasks,
    },
    yPosition: y,
  }, pdfDoc);
  y = chartResult.y;
  ctx = chartResult.ctx;

  return { ...ctx, yPosition: y };
}

/**
 * Render task lifecycle report
 */
function renderTaskLifecycleReport(ctx: PageContext, data: any, pdfDoc: PDFDocument): PageContext {
  let y = ctx.yPosition;
  const content = data.content;

  // Overview
  ctx.page.drawText(`Total Tasks: ${content.totalTasks}`, {
    x: MARGIN,
    y,
    size: 14,
    font: ctx.fontBold,
    color: COLORS.text,
  });
  y -= LINE_HEIGHT * 1.5;

  // Status distribution
  const chartResult = renderBarChart(ctx, {
    title: 'Tasks by Lifecycle Stage',
    data: content.statusCounts,
    yPosition: y,
  }, pdfDoc);
  y = chartResult.y;
  ctx = chartResult.ctx;

  // Metrics table
  y -= SECTION_SPACING;
  const pageCheck2 = checkNewPage(y, ctx, pdfDoc);
  y = pageCheck2.y;
  ctx = pageCheck2.ctx;
  ctx.page.drawText('Performance Metrics', {
    x: MARGIN,
    y,
    size: 14,
    font: ctx.fontBold,
    color: COLORS.text,
  });
  y -= LINE_HEIGHT * 1.5;

  const metrics = [
    { label: 'Tasks Reopened', value: content.reopenedCount },
    { label: 'Bottlenecks (>7 days pending)', value: content.bottlenecks, color: content.bottlenecks > 0 ? COLORS.danger : COLORS.text },
  ];

  metrics.forEach((metric) => {
    const pageCheck = checkNewPage(y, ctx, pdfDoc);
    y = pageCheck.y;
    ctx = pageCheck.ctx;
    ctx.page.drawText(`${metric.label}:`, {
      x: MARGIN + 20,
      y,
      size: 10,
      font: ctx.font,
      color: COLORS.textSecondary,
    });
    ctx.page.drawText(String(metric.value), {
      x: ctx.width - MARGIN - 100,
      y,
      size: 11,
      font: ctx.fontBold,
      color: metric.color || COLORS.text,
    });
    y -= LINE_HEIGHT;
  });

  return { ...ctx, yPosition: y };
}

/**
 * Render project report
 */
function renderProjectReport(ctx: PageContext, data: any, pdfDoc: PDFDocument): PageContext {
  let y = ctx.yPosition;
  const content = data.content;

  // Project info
  ctx.page.drawText(`Project: ${content.project.name}`, {
    x: MARGIN,
    y,
    size: 14,
    font: ctx.fontBold,
    color: COLORS.text,
  });
  y -= LINE_HEIGHT * 1.5;

  ctx.page.drawText(`Status: ${content.project.status}`, {
    x: MARGIN + 10,
    y,
    size: 11,
    font: ctx.font,
    color: COLORS.text,
  });
  y -= SECTION_SPACING;

  // Task distribution chart
  const chartResult = renderBarChart(ctx, {
    title: 'Task Distribution by Status',
    data: content.statusCounts,
    yPosition: y,
  }, pdfDoc);
  y = chartResult.y;
  ctx = chartResult.ctx;

  // Summary
  y -= SECTION_SPACING;
  const pageCheck2 = checkNewPage(y, ctx, pdfDoc);
  y = pageCheck2.y;
  ctx = pageCheck2.ctx;
  ctx.page.drawText('Summary', {
    x: MARGIN,
    y,
    size: 14,
    font: ctx.fontBold,
    color: COLORS.text,
  });
  y -= LINE_HEIGHT * 1.5;

  const summary = [
    { label: 'Total Tasks', value: content.totalTasks },
    { label: 'Completed', value: content.completed, color: COLORS.success },
    { label: 'Pending', value: content.pending },
  ];

  summary.forEach((item) => {
    const pageCheck = checkNewPage(y, ctx, pdfDoc);
    y = pageCheck.y;
    ctx = pageCheck.ctx;
    ctx.page.drawText(`${item.label}:`, {
      x: MARGIN + 20,
      y,
      size: 10,
      font: ctx.font,
      color: COLORS.textSecondary,
    });
    ctx.page.drawText(String(item.value), {
      x: ctx.width - MARGIN - 100,
      y,
      size: 11,
      font: ctx.fontBold,
      color: item.color || COLORS.text,
    });
    y -= LINE_HEIGHT;
  });

  return { ...ctx, yPosition: y };
}

/**
 * Render company-wide report
 */
function renderCompanyWideReport(ctx: PageContext, data: any, pdfDoc: PDFDocument): PageContext {
  let y = ctx.yPosition;
  const content = data.content;

  // Overview metrics
  const overview = [
    { label: 'Total Users', value: content.totalUsers },
    { label: 'Total Projects', value: content.totalProjects },
    { label: 'Total Tasks', value: content.totalTasks },
  ];

  overview.forEach((item) => {
    const pageCheck = checkNewPage(y, ctx, pdfDoc);
    y = pageCheck.y;
    ctx = pageCheck.ctx;
    ctx.page.drawText(`${item.label}:`, {
      x: MARGIN,
      y,
      size: 12,
      font: ctx.fontBold,
      color: COLORS.text,
    });
    ctx.page.drawText(String(item.value), {
      x: ctx.width - MARGIN - 100,
      y,
      size: 14,
      font: ctx.fontBold,
      color: COLORS.primary,
    });
    y -= LINE_HEIGHT * 1.2;
  });

  y -= SECTION_SPACING;

  // Task distribution chart
  const chartResult = renderBarChart(ctx, {
    title: 'Company Task Distribution',
    data: content.statusCounts,
    yPosition: y,
  }, pdfDoc);
  y = chartResult.y;
  ctx = chartResult.ctx;

  // Risk indicators
  if (content.overdueCount > 0 || content.pendingReviewCount > 0) {
    y -= SECTION_SPACING;
    const pageCheck2 = checkNewPage(y, ctx, pdfDoc);
    y = pageCheck2.y;
    ctx = pageCheck2.ctx;
    ctx.page.drawText('Risk Indicators', {
      x: MARGIN,
      y,
      size: 14,
      font: ctx.fontBold,
      color: COLORS.text,
    });
    y -= LINE_HEIGHT * 1.5;

    if (content.overdueCount > 0) {
      const pageCheck3 = checkNewPage(y, ctx, pdfDoc);
      y = pageCheck3.y;
      ctx = pageCheck3.ctx;
      ctx.page.drawText(`  - ${content.overdueCount} overdue task(s)`, {
        x: MARGIN + 10,
        y,
        size: 11,
        font: ctx.font,
        color: COLORS.danger,
      });
      y -= LINE_HEIGHT;
    }

    if (content.pendingReviewCount > 0) {
      const pageCheck4 = checkNewPage(y, ctx, pdfDoc);
      y = pageCheck4.y;
      ctx = pageCheck4.ctx;
      ctx.page.drawText(`  - ${content.pendingReviewCount} task(s) pending review`, {
        x: MARGIN + 10,
        y,
        size: 11,
        font: ctx.font,
        color: COLORS.warning,
      });
      y -= LINE_HEIGHT;
    }
  }

  return { ...ctx, yPosition: y };
}

/**
 * Render a simple bar chart
 */
function renderBarChart(ctx: PageContext, options: {
  title: string;
  data: Record<string, number>;
  yPosition: number;
}, pdfDoc: PDFDocument): { y: number; ctx: PageContext } {
  let y = options.yPosition;

  // Check if we have enough space for the chart before rendering
  const chartHeight = 150;
  const labelSpace = 40; // Space for labels below chart
  const totalSpaceNeeded = LINE_HEIGHT * 2 + chartHeight + labelSpace;
  
  const pageCheck = checkNewPage(y, ctx, pdfDoc, totalSpaceNeeded);
  y = pageCheck.y;
  ctx = pageCheck.ctx;

  // Chart title
  ctx.page.drawText(options.title, {
    x: MARGIN,
    y,
    size: 12,
    font: ctx.fontBold,
    color: COLORS.text,
  });
  y -= LINE_HEIGHT * 1.5;

  const chartWidth = ctx.width - MARGIN * 2;
  const dataEntries = Object.entries(options.data);
  const barWidth = Math.min((chartWidth - (dataEntries.length - 1) * 10) / dataEntries.length, 80);
  const maxValue = Math.max(...Object.values(options.data), 1);
  const barStartX = MARGIN;
  const barStartY = y - chartHeight;

  // Draw bars
  let x = barStartX;
  dataEntries.forEach(([label, value]) => {
    const barHeight = (value / maxValue) * chartHeight;
    const color = label === 'Closed' || label === 'Completed' ? COLORS.success :
                  label === 'Done' || label === 'Pending Review' ? COLORS.warning :
                  label === 'Overdue' ? COLORS.danger : COLORS.primary;

    // Bar
    ctx.page.drawRectangle({
      x,
      y: barStartY,
      width: barWidth,
      height: barHeight,
      color,
      borderColor: COLORS.border,
      borderWidth: 1,
    });

    // Value label on bar
    if (barHeight > 15) {
      ctx.page.drawText(String(value), {
        x: x + barWidth / 2 - 5,
        y: barStartY + barHeight / 2 - 3,
        size: 9,
        font: ctx.fontBold,
        color: rgb(1, 1, 1), // White text on colored bar
      });
    }

    // Category label below bar
    ctx.page.drawText(label, {
      x: x + 5,
      y: barStartY - 20,
      size: 8,
      font: ctx.font,
      color: COLORS.textSecondary,
    });

    x += barWidth + 10;
  });

  // Return position after chart with extra spacing
  return { y: barStartY - 40, ctx };
}

/**
 * Check if new page is needed and create one if necessary
 */
function checkNewPage(y: number, ctx: PageContext, pdfDoc: PDFDocument, requiredSpace: number = LINE_HEIGHT * 3): { y: number; ctx: PageContext } {
  if (y < MARGIN + requiredSpace) {
    const newPage = pdfDoc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
    const newCtx = { ...ctx, page: newPage, yPosition: PAGE_HEIGHT - MARGIN };
    return { y: PAGE_HEIGHT - MARGIN, ctx: newCtx };
  }
  return { y, ctx };
}
